# Caching 

- 利用引用局部性原理：最近请求的数据可能会再次被请求。
- 存在于架构的各个层次，但通常在最靠近前端的层次找到。

## Application Server Cache (应用服务器缓存)
- 缓存在请求层节点上。
- 当请求层节点扩展到多个节点时：
  - 负载均衡器随机分配请求到各个节点。
  - 相同请求可能发送到不同节点。
  - 增加缓存未命中。
  - 解决方案：
    - 全局缓存
    - 分布式缓存

## Distributed Cache (分布式缓存)
- 每个请求层节点拥有部分缓存数据。
- 整个缓存通过一致性哈希函数划分。
- 优点：
  - 通过向请求池中添加更多节点，可以轻松增加缓存空间。
- 缺点：
  - 缺少节点会导致缓存丢失。

## Global Cache (全局缓存)
- 一个比原始存储更快的服务器或文件存储，并且可以被所有请求层节点访问。
- 两种常见形式：
  - 缓存服务器处理缓存未命中。
    - 被大多数应用使用。
  - 请求节点处理缓存未命中。
    - 在缓存中拥有大比例的热点数据集。
    - 一种架构，其中缓存中存储的文件是静态的，不应该被逐出。
    - 应用逻辑比缓存更了解逐出策略或热点。

## Content Distributed Network (CDN) (内容分发网络)
- 用于提供大量静态媒体的网站。
- 过程：
  - 请求首先向CDN请求静态媒体。
  - 如果CDN本地有该内容，则提供该内容。
  - 如果内容不可用，CDN将查询后端服务器获取文件，在本地缓存并提供给请求用户。
- 如果系统不够大以支持CDN，可以这样构建：
  - 使用轻量级HTTP服务器（例如Nginx）从单独的子域提供静态媒体。
  - 以后可以将这个子域的DNS切换到CDN。

## Cache Invalidation (缓存失效)
- 保持缓存与真实数据源一致。当真实数据源更改时，使缓存失效。
- Write-through Cache (写穿缓存)
  - 数据同时写入缓存和永久存储。
  - 优点：
    - 快速检索，完全数据一致性，对系统中断具有鲁棒性。
  - 缺点：
    - 写操作的延迟更高。
- Write-around Cache (写旁缓存)
  - 数据写入永久存储，而不是缓存。
  - 优点：
    - 减少未使用的缓存。
  - 缺点：
    - 查询最近写入的数据会产生缓存未命中和更高的延迟。
- Write-back Cache (写回缓存)
  - 数据仅写入缓存。
  - 稍后写入永久存储。
  - 优点：
    - 低延迟，高吞吐量，适用于写密集型应用。
  - 缺点：
    - 系统中断时有数据丢失的风险。

## Cache Eviction Policies (缓存逐出策略)
- FIFO: 先进先出
- LIFO: 后进先出
- LRU: 最近最少使用
- MRU: 最近最多使用
- LFU: 最少使用
- RR: 随机替换