import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# 代理模式
:::tip
代理模式：代理和被代理的对象实现了相同的接口，注意接口承担了所有的抽象
:::

## 思路讲解
```mermaid
classDiagram
    class Subject {
        <<interface>>
        +DoAction()
    }

    class RealSubject {
        +DoAction()
    }

    class Proxy {
        -subject Subject
        +DoAction()
    }

    Subject <|.. RealSubject
    Subject <|.. Proxy
    Proxy o-- Subject
```

以下是你的 Go 代码的类图，用 Mermaid 格式表示：


- `Subject` 是一个接口，定义了 `DoAction` 方法。
- `RealSubject` 实现了 `Subject` 接口，并定义了 `DoAction` 方法的具体操作。
- `Proxy` 也实现了 `Subject` 接口，但其 `DoAction` 方法包含了额外的逻辑，并代理 `RealSubject` 的 `DoAction` 方法。
- `Proxy` 包含一个 `Subject` 类型的成员变量 `subject`，用于保存被代理的 `RealSubject` 实例。
- 类图中箭头表示继承关系和关联关系：
  - `Subject <|.. RealSubject` 和 `Subject <|.. Proxy` 表示 `RealSubject` 和 `Proxy` 实现了 `Subject` 接口。
  - `Proxy o-- Subject` 表示 `Proxy` 持有一个 `Subject` 的实例。

通过这个类图，可以清晰地看到代理模式的结构以及各个类之间的关系。
## 代码实现

<Tabs>
    <TabItem value="golang" label="Golang">

        ```go showLineNumbers {6,22-24}
        package main

        import "fmt"

        type Subject interface {
            DoAction() //注意 Proxy 和 被Proxy代理的对象都实现了同一个 DoAction 接口
        }

        //代理模式
        //-----------------真实操作-----------------
        type RealSubject struct {}

        func (r *RealSubject) DoAction() {
            fmt.Println("执行真实操作")
        }
        //-----------------代理操作-----------------
        type Proxy struct {
            subject Subject
        }

        func (p *Proxy) DoAction() {
            fmt.Println("开始执行代理") //代理模式的额外动作
            p.subject.DoAction()
            fmt.Println("代理执行结束") //代理模式的额外动作
        }

        func main() {
            proxy := &Proxy{subject: &RealSubject{}}
            proxy.DoAction()
        }
        ```

    </TabItem>
    <TabItem value="ts" label="TypeScript">

        ```ts
        //无内容
        var a = 1;
        ```

    </TabItem>
</Tabs>


